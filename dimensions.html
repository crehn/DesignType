<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" type="image/png" href="./favicon.png">
    <link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./favicon.png">
    <link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap-theme.min.css">
    <link rel="stylesheet" href="bower_components/jquery-ui/themes/ui-lightness/jquery-ui.min.css">
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="comments.css" />

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="bower_components/html5shiv/dist/html5shiv.js"></script>
      <script src="bower_components/respond.js/dest/respond.min.js"></script>
    <![endif]-->
    
    <script type="text/javascript">
       var pageIdComments = 1;
    </script>

    <title>How Do You Design Software?</title>
</head>
<body>
<div class="container page">
    <nav class="navbar navbar-inverse navbar-default" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="index.html">Design Types</a>
            </div>
            <div class="collapse navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="test_yourself.html">Test Yourself</a></li>
                    <li><a href="assess_colleagues.html?revealed">Assess Colleagues</a></li>
                    <li class="active"><a href="info.html">Learn More</a></li>
                    <li><a href="about.html">About</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://www.principles-wiki.net">principles-wiki.net</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="jumbotron">
        <h1>How Do You Design Software?</h1>
        <p>
            Read about the dimensions.
        </p>
    </div>

    <section>
        <h1>Introduction</h1>
        <p>
            In order to distinguish how developers think when making design decisions, one can distinguish four dimensions: 
            <ul>
              <li><b>simple-vs-powerful</b></li>
              <li><b>abstract-vs-concrete</b></li>
              <li><b>pragmatic-vs-idealistic</b></li>
              <li><b>technologic-vs-robust</b></li>
            </ul>
            These dimensions are described here:
        </p>
    </section>
    <section id="dimensions">
        <h2 id="simple">Simple</h2>
        <div>
            <p>
                Developers with this attitude prefer simple solutions which are easy to write and maintain.
            </p>
            <p>
                The main idea is avoiding complexity. To prefer simple solutions means to implement only necessary and requested things without any frills. Simple code is easier to read, better to maintain, and cointains fewer bugs. Typical followers know about the power of simplicity. The key to handling complexity is not to master it but rather to avoid it. They prefer small and clear modules with few dependencies. They use libraries and frameworks if this makes the code easier to read and write and they don't use them if this only means that the reader of the code needs to know how all these libraries work. Explicit solutions are preferred to indirect, declaratrive ones. This means that simple solutions are not overly generic but they communicate the intent well.
            </p>
            <p>
                On the other hand simple design tends to be less foresighted. This makes frequent changes and refactorings necessary. While this is not a problem for a single class, it may become one when interfaces to other teams are affected. Simple and explicit solutions often tend to be tightly coupled to requirements, used libraries and external dependencies. Decoupling introduces complexity (additional abstraction layers, indirect calls, etc.) but it also provides flexibility. This flexibility is sometimes underused by simple developers.
            </p>
            <p>
                Simple developers typically follow the following principles:
                <a href="http://www.principles-wiki.net/principles:keep_it_simple_stupid">KISS</a>, 
                <a href="http://www.principles-wiki.net/principles:more_is_more_complex">MIMC</a>, 
                <a href="http://www.principles-wiki.net/principles:you_ain_t_gonna_need_it">YAGNI</a>, 
                <a href="http://www.principles-wiki.net/principles:rule_of_explicitness">RoE</a>, 
                and <a href="http://www.principles-wiki.net/principles:principle_of_least_surprise">PLS</a> 
            </p>
            <p>
                Rather disregarded principles for these developers are: 
                <a href="http://www.principles-wiki.net/principles:generalization_principle">GP</a>
                and <a href="http://www.principles-wiki.net/principles:low_coupling">LC</a>
            </p>
        </div>
        <h2 id="powerful">Powerful</h2>
        <div>
            <p>
                Developers with this attitude prefer powerful, flexible, and foresighted solutions.
            </p>
            <p>
                The main idea is to create flexible and foresightes solutions. Generalized solutions can be applied for several use cases by just customizing or configuring them. Followers typically include flexibility and extensibility naturally into software design. Powerful developers like runtime configurability, powerful frameworks, decoupling, and the use of many design patterns. They think ahead and include thoughts on extensibility, performance, and portability into their design process. This keeps structures and interfaces stable and helps reducing effort imposed by changing requirements inthe future.
            </p>
            <p>
                On the other hand powerful solutions take much time especially for their initial creation. Some of the flexiobility might never be used so one could argure that introducing it was unnecessary effort. Powerful developers may tend also to get lost in providing flexibility instead of fulfilling requirements. Powerful code is flexible and foresighted but it is also hard to read and to understand. Furthermore complex and powerful solutions are more error-prone than simple ones.
            </p>
            <p>
                Powerful developers typically follow the following principles:
                <a href="http://www.principles-wiki.net/principles:generalization_principle">GP</a>,
                <a href="http://www.principles-wiki.net/principles:encapsulate_the_concept_that_varies">ECV</a>,
                <a href="http://www.principles-wiki.net/principles:information_hiding_encapsulation">IH/E</a>,
                <a href="http://www.principles-wiki.net/principles:dependency_inversion_principle">DIP</a>, 
                and <a href="http://www.principles-wiki.net/principles:low_coupling">LC</a>
            </p>
            <p>
                Rather disregarded principles for these developers are: 
                <a href="http://www.principles-wiki.net/principles:keep_it_simple_stupid">KISS</a>, 
                <a href="http://www.principles-wiki.net/principles:more_is_more_complex">MIMC</a>, 
                <a href="http://www.principles-wiki.net/principles:you_ain_t_gonna_need_it">YAGNI</a>, 
                and <a href="http://www.principles-wiki.net/principles:rule_of_explicitness">RoE</a>
            </p>
        </div>
        <h2 id="abstract">Abstract</h2>
        <div>
            <p>
                Developers with this attitude think in terms of abstractions and concepts.
            </p>
            <p>
                Abstract developers always have the big picture in mind. They think in terms of abstraction layers, patterns, package dependencies, architectural constraints, etc. Structure is very important and abstract developery keep the structure clean and clearly arranged. Single lines of code are not impotent. You shouldn't look at a software system with a magnifying glass. It has to work as a whole and it can be understood as a whole. Abstract solutions follow clear concepts that are easy to uderstand and fundamental to the whole system. Followers have a very good overview over the whole system. Furthermore they are also able to give advice on consequences of particular changes. Often abstract developers also like having natural, requirements-based object-designs where the software structure mimics the real-world concepts. This can make understanding the code even easier and may lead to fewer code changes when requirements change.
            </p>
            <p>
                Abstract developers typically don't like working with legacy code that has bad structure. They feel the need to understand the system as a whole and will try to refactor the code such that there is a clear structure. If there is time for that and the system will be maintaines further, this is a good thing. In the other cases an abstract developer will feel lost and will be unhappy with making changes to that code which he doesn't quite understand.
            </p>
            <p>
                Abstract developers typically follow the following principles: 
                <a href="http://www.principles-wiki.net/principles:low_coupling">LC</a>,
                <a href="http://www.principles-wiki.net/principles:tell_don_t_ask_information_expert">TdA/IE</a>, 
                <a href="http://www.principles-wiki.net/principles:principle_of_separate_understandability">PSU</a>,
                <a href="http://www.principles-wiki.net/principles:high_cohesion">HC</a>, 
                <a href="http://www.principles-wiki.net/principles:information_hiding_encapsulation">IH/E</a>,
                <a href="http://www.principles-wiki.net/principles:single_level_of_abstraction">SLA</a>, 
                <a href="http://www.principles-wiki.net/principles:model_principle">MP</a>,
                and <a href="http://www.principles-wiki.net/principles:uniformity_principle">UP</a>
            </p>
            <p>
                Rather disregarded principles for these developers are: 
                <a href="http://www.principles-wiki.net/principles:rule_of_explicitness">RoE</a>,
                <a href="http://www.principles-wiki.net/principles:encapsulate_the_concept_that_varies">ECV</a>,
                and <a href="http://www.principles-wiki.net/principles:you_ain_t_gonna_need_it">YAGNI</a>
            </p>
        </div>
        <h2 id="concrete">Concrete</h2>
        <div>
            <p>
                Developers with this attitude directly think in terms of code.
            </p>
            <p>
                Concrete developers directly transfer requirements to code. They are also good at working with and even refactoring legacy code that they do not completely understand. They don't have to understand the whole system in all its details and they know that thsi attitude wouldn't scale either. As soon as a system has a certain level of complexity, one mind cannot understand it fully. Nevertheless a concrete developer can work quite well with such a system. When they refactor they heavyly rely on the boyscout rule. They improve code bottom-up rather than planning it top-down.
            </p>
            <p>
                On the other hand concrete developers may overoptimize unnecessary details and tend to loose sight of the big picture. They may violate achitectural constraints and weaken the overall structure because thinking in terms of packages, layers and dependencies is not in their focus.
            </p>
            <p>
                Concrete developers typically follow the following principles: 
                <a href="http://www.principles-wiki.net/principles:don_t_repeat_yourself">DRY</a>,
                <a href="http://www.principles-wiki.net/principles:high_cohesion">HC</a>,
                <a href="http://www.principles-wiki.net/principles:single_responsibility_principle">SRP</a>,
                <a href="http://www.principles-wiki.net/principles:encapsulate_the_concept_that_varies">ECV</a>,
                and <a href="http://www.principles-wiki.net/principles:open-closed_principle">OCP</a> 
            </p>
            <p>
                Rather disregarded principles for these developers are:
                <a href="http://www.principles-wiki.net/principles:model_principle">MP</a>,
                <a href="http://www.principles-wiki.net/principles:tell_don_t_ask_information_expert">TdA/IE</a>,
                <a href="http://www.principles-wiki.net/principles:principle_of_separate_understandability">PSU</a>,
                and <a href="http://www.principles-wiki.net/principles:liskov_substitution_principle">LSP</a>
            </p>
        </div>
        <h2 id="pragmatic">Pragmatic</h2>
        <div>
            <p>
                Developers with this attitude focus on time to market.
            </p>
            <p>
                The main motivation of this dimension is to fulfill requested requirements as soon as possible. The end justifies the means implies that only those things will be used that guarantee a certain value. Unnecessary ones will be omitted. This approach prevents complexity and confusing situations in the first place. Followers do not like to invent the wheel and use templates, code snippets, etc. to avoid implementing everything by their own. This normally leads to faster solutions and success. Freed from technical or structural sensitivities followers of this dimension adapt very fast to any new environment, rules or specifications for example to a new team. They are also able to bring others back to earth and redirect them to the origin goal.
            </p>
            <p>
                Downside of this dimension is that followers accept incompleteness. This means for example that quality, structure, symmetry or anything else can be affected negatively. Shortcomings in structure can violate the architecture; shortcomings in symmetry can lead to uncertain terminology and for this to less understandable Code. Shortcomings in code style normally leads to less maintainable code, etc. Besides this usage of code snippets can contain risks especially if its contents have not been understood totally or mandatory context knowledge is missing. The lack of detailed knowledge can also lead to onions by adding layers surround existing code instead of refactoring the design. Often used copy and paste parts can raise one bug several times. All in all sustainability is often sacrificed for quick results.
            </p>
            <p>
                Typical applied principles for dimension pragmatic are: YAGNI, RoE, KISS, MIMC 
            </p>
            <p>
                Irrelevant principles for this dimension are (maybe also interesting to have an eye on it): UP, GP, MP, LSP, IH/E, DIP, LC, HC, TdA/IE, EUHM, IAP
            </p>
        </div>
        <h2 id="idealistic">Idealistic</h2>
        <div>
            <p>
                Developers with this attitude prefer clean solutions.
            </p>
            <p>
                The main motivation of this dimension is doing it right or let it be. Sustainability is a very important aspect that pays back at the latest in the long term. Is everything at the right placed and implemented correctly there will be less disappointment and less effort instead of continous changes. Everything also implies to consider non functional requirements as well which leads to well prepared solutions. Several other aspects like logging, exception handling, security, defensive programming, test strategy, etc. will be also considered from begin on. Symmetrie in code and well understandable terms lead to a better understandability and maintainability. Beeing idealistic means doing things more precisely and intensive which boosts other positive aspects of this species.
            </p>
            <p>
                Downside of this dimension is that boosting works in two ways. Negative aspects will be boosted also and can worsen everything. To achieve a certain degree of perfection costs much effort and is not fitting to each situation. A typical goal like reaching completeness often ends in unnecessary complexity. There is a risk of loosing focus on real requirements or real goals by striving towards sustainability and perfection. Economical aspects will be often omitted. Followers can also tend to hyperbolism and this attitude may end up in religious discussions or in ones without an outcome.
            </p>
            <p>
                Typical applied principles for dimension idealistic are: UP, PSU, DRY, IH/E, furthermore being idealistic adds even more weight on the principles you favor because of the other dimensions 
            </p>
            <p>
                Irrelevant principles for this dimension are (maybe also interesting to have an eye on it): KISS, MIMC
            </p>
        </div>
        <h2 id="technologic">Technologic</h2>
        <div>
            <p>
                Developers with this attitude prefer technically advanced solutions.
            </p>
            <p>
                New technologies offer the chance to revolutionize existing mindsets and approaches making existing ones obsolete. It also extends the own horizon and keep oneself open minded. Taking proactively part on future trends protects from building legacy and keeps oneself competitive. Updating continuously safes maintainance time and prevents risks. Followers benefit from a big set of knowledge and experience and often achieve more creative solutions than others. Continuously improving enables being more effective and efficient and the ability to adapt faster to unknown concepts and code.
            </p>
            <p>
                On the other hand there is a risk to ride the wrong horse means to follow the wrong hype that may have catastrophic consequences (often especially for stability). Besides this too many influences can disturb the homogeneity of systems, designs, code styles, etc. and increase complexity. Additonally each change can raise several implications like building up knowledge, breaking up exisiting mindsets, etc. In extrem cases much time will get lost for playing around with new technologies without any outcome. Last but not least there is a risk to loose focus of the real goal. Follower need their space and can react allergic if it will be limited too close or will get bored. This can lead to disregarding common structure like design or architecture.
            </p>
            <p>
                Typical applied principles for dimension idealistic are: ECV, GP, DRY 
            </p>
            <p>
                Irrelevant principles for this dimension are (maybe also interesting to have an eye on it): UP, KISS, MIMC, PLS
            </p>
        </div>
        <h2 id="robust">Robust</h2>
        <div>
            <p>
                Developers with this attitude prefer stabe solutions which stood the test of time.
            </p>
            <p>
                Stability of applications or systems prevents risks and protects from problems. Each kind of change typically contains a risk and limitation of risks also means to limitate changes like new technologies or unnecessary updates. To gain a certain level of homogenous and stable structure instead of heading towards to a chaotic zoo there is a need for standards. These standards lead to better understandable systems. In general only reality proven elements or those that stood a substantiated check will be used in practice. Any kind of magic that mainly increases complexity will be avoided or omitted. Instead of this effort will be invested in protecting oneself from manipulative intrusions. Consequences are that bugs can be investigated more precisely and fixed faster also if source code is unknown. Follower often think beyond the code itself for example about logging, exception handling, security, defensive programming, test strategy, etc.
            </p>
            <p>
                Reaching robustness demands effort and time. In the worst case it means to loose catching up new technologies that would make things easier or faster. In comparison with others that use new technologies it can lead to frustration. Protecting code often also leads to more complex or overweight code that is thus hard to understand. Follower have to take care not being noticed as a guy who slows down everything.
            </p>
            <p>
                Typical applied principles for dimension idealistic are: ML, EUHM, UP, IH/E 
            </p>
            <p>
                Irrelevant principles for this dimension are (maybe also interesting to have an eye on it): KISS
            </p>
        </div>
    </section>
    <section id="comments">
        <div class="row">
			<div id="templateSingleComment" class="cmt-cnt">
			    <img src="missing.png">
			    <div class="thecom">
			        <h5>Template name</h5><span class="com-dt">Template date</span>
			        <br>
			        <p>Template comment</p>
			    </div>
			</div>
			
			<div id="commentscontainer" class="cmt-container">
			    <div class="new-com-bt">
			        <span>Write a comment ...</span>
			    </div>
			    <div id="commentform" class="new-com-cnt">
			        <input id="name-com" name="name-com" value="" placeholder="Your name" type="text">
			        <input id="mail-com" name="mail-com" value="" placeholder="Your e-mail adress" type="text">
			        <textarea class="the-new-com"></textarea>
			        <div class="bt-add-com">Post comment</div>
			        <div class="bt-cancel-com">Cancel</div>
			    </div>
			    <div class="clear"></div>
			</div>  
		</div>  
    </section>
    <footer>
        Please give us <a href="mailto:email@design-types.net">Feedback</a> or discuss with us at <a href="https://www.xing.com/communities/groups/design-principles-patterns-types-08d2-1080100" target="_blank"><img src="./img/xing_logo2.png" alt="XING" height="25" width="25" /></a>
    </footer>
</div>

<script src="bower_components/jquery/dist/jquery.min.js"></script>
<script src="bower_components/jquery-ui/ui/minified/jquery-ui.min.js"></script>
<script src="bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
<script src="dimensions.js"></script>
<script src="comments.js"></script>
</body>
</html>
