<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" type="image/png" href="./favicon.png">
    <link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./favicon.png">
    <link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap-theme.min.css">
    <link rel="stylesheet" href="bower_components/jquery-ui/themes/ui-lightness/jquery-ui.min.css">
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="comments.css" />

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="bower_components/html5shiv/dist/html5shiv.js"></script>
      <script src="bower_components/respond.js/dest/respond.min.js"></script>
    <![endif]-->
    
    <script type="text/javascript">
       var pageIdComments = 1;
    </script>

    <title>How Do You Design Software?</title>
</head>
<body>
<div class="container page">
    <nav class="navbar navbar-inverse navbar-default" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="index.html">Design Types</a>
            </div>
            <div class="collapse navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="test_yourself.html">Test Yourself</a></li>
                    <li><a href="assess_colleagues.html?revealed">Assess Colleagues</a></li>
                    <li class="active"><a href="info.html">Learn More</a></li>
                    <li><a href="statistics.html">Statistics</a></li>
                    <li><a href="about.html">About</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://www.principles-wiki.net">principles-wiki.net</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="jumbotron">
        <h1>How Do You Design Software?</h1>
        <p>
            Read about the dimensions.
        </p>
    </div>

    <section>
        <h1>Introduction</h1>
        <p>
            In order to distinguish how developers think when making design decisions, one can distinguish four dimensions: 
            <ul>
              <li><b>simple-vs-powerful</b></li>
              <li><b>abstract-vs-concrete</b></li>
              <li><b>pragmatic-vs-idealistic</b></li>
              <li><b>technologic-vs-robust</b></li>
            </ul>
            These dimensions are described here:
        </p>
    </section>
    <section id="dimensions">
        <h2 id="simple">Simple</h2>
        <div>
            <p>
                Developers with this attitude prefer simple solutions which are easy to write and to maintain.
            </p>
            <p>
                The main idea is avoiding complexity. To prefer simple solutions means to implement only necessary and requested things without any frills. Simple code is easier to read, better to maintain, and cointains fewer bugs. Typical followers know about the power of simplicity. The key to handling complexity is not to master it but rather to avoid it. They prefer small and clear modules with few dependencies. They use libraries and frameworks if this makes the code easier to read and write and they don't use them if this only means that the reader of the code needs to know how all these libraries work. Explicit solutions are preferred to indirect, declaratrive ones. This means that simple solutions are not overly generic but they communicate the intent well.
            </p>
            <p>
                On the other hand simple design tends to be less foresighted. This makes frequent changes and refactorings necessary. While this is not a problem for a single class, it may become one when interfaces to other teams are affected. Simple and explicit solutions often tend to be tightly coupled to requirements, used libraries and external dependencies. Decoupling introduces complexity (additional abstraction layers, indirect calls, etc.) but it also provides flexibility. This flexibility is sometimes underused by simple developers.
            </p>
            <p>
                Simple developers typically follow the following principles:
                <a href="http://www.principles-wiki.net/principles:keep_it_simple_stupid">KISS</a>, 
                <a href="http://www.principles-wiki.net/principles:more_is_more_complex">MIMC</a>, 
                <a href="http://www.principles-wiki.net/principles:you_ain_t_gonna_need_it">YAGNI</a>, 
                <a href="http://www.principles-wiki.net/principles:rule_of_explicitness">RoE</a>, 
                and <a href="http://www.principles-wiki.net/principles:principle_of_least_surprise">PLS</a> 
            </p>
            <p>
                Rather disregarded principles for these developers are: 
                <a href="http://www.principles-wiki.net/principles:generalization_principle">GP</a>
                and <a href="http://www.principles-wiki.net/principles:low_coupling">LC</a>
            </p>
        </div>
        <h2 id="powerful">Powerful</h2>
        <div>
            <p>
                Developers with this attitude prefer powerful, flexible, and foresighted solutions.
            </p>
            <p>
                The main idea is to create flexible and foresightes solutions. Generalized solutions can be applied for several use cases by just customizing or configuring them. Followers typically include flexibility and extensibility naturally into software design. Powerful developers like runtime configurability, powerful frameworks, decoupling, and the use of many design patterns. They think ahead and include thoughts on extensibility, performance, and portability into their design process. This keeps structures and interfaces stable and helps reducing effort imposed by changing requirements inthe future.
            </p>
            <p>
                On the other hand powerful solutions take much time especially for their initial creation. Some of the flexiobility might never be used so one could argure that introducing it was unnecessary effort. Powerful developers may tend also to get lost in providing flexibility instead of fulfilling requirements. Powerful code is flexible and foresighted but it is also hard to read and to understand. Furthermore complex and powerful solutions are more error-prone than simple ones.
            </p>
            <p>
                Powerful developers typically follow the following principles:
                <a href="http://www.principles-wiki.net/principles:generalization_principle">GP</a>,
                <a href="http://www.principles-wiki.net/principles:encapsulate_the_concept_that_varies">ECV</a>,
                <a href="http://www.principles-wiki.net/principles:information_hiding_encapsulation">IH/E</a>,
                <a href="http://www.principles-wiki.net/principles:dependency_inversion_principle">DIP</a>, 
                and <a href="http://www.principles-wiki.net/principles:low_coupling">LC</a>
            </p>
            <p>
                Rather disregarded principles for these developers are: 
                <a href="http://www.principles-wiki.net/principles:keep_it_simple_stupid">KISS</a>, 
                <a href="http://www.principles-wiki.net/principles:more_is_more_complex">MIMC</a>, 
                <a href="http://www.principles-wiki.net/principles:you_ain_t_gonna_need_it">YAGNI</a>, 
                and <a href="http://www.principles-wiki.net/principles:rule_of_explicitness">RoE</a>
            </p>
        </div>
        <h2 id="abstract">Abstract</h2>
        <div>
            <p>
                Developers with this attitude think in terms of abstractions and concepts.
            </p>
            <p>
                Abstract developers always have the big picture in mind. They think in terms of abstraction layers, patterns, package dependencies, architectural constraints, etc. Structure is very important and abstract developery keep the structure clean and clearly arranged. Single lines of code are not impotent. You shouldn't look at a software system with a magnifying glass. It has to work as a whole and it can be understood as a whole. Abstract solutions follow clear concepts that are easy to uderstand and fundamental to the whole system. Followers have a very good overview over the whole system. Furthermore they are also able to give advice on consequences of particular changes. Often abstract developers also like having natural, requirements-based object-designs where the software structure mimics the real-world concepts. This can make understanding the code even easier and may lead to fewer code changes when requirements change.
            </p>
            <p>
                Abstract developers typically don't like working with legacy code that has bad structure. They feel the need to understand the system as a whole and will try to refactor the code such that there is a clear structure. If there is time for that and the system will be maintaines further, this is a good thing. In the other cases an abstract developer will feel lost and will be unhappy with making changes to that code which he doesn't quite understand.
            </p>
            <p>
                Abstract developers typically follow the following principles: 
                <a href="http://www.principles-wiki.net/principles:low_coupling">LC</a>,
                <a href="http://www.principles-wiki.net/principles:tell_don_t_ask_information_expert">TdA/IE</a>, 
                <a href="http://www.principles-wiki.net/principles:principle_of_separate_understandability">PSU</a>,
                <a href="http://www.principles-wiki.net/principles:high_cohesion">HC</a>, 
                <a href="http://www.principles-wiki.net/principles:information_hiding_encapsulation">IH/E</a>,
                <a href="http://www.principles-wiki.net/principles:single_level_of_abstraction">SLA</a>, 
                <a href="http://www.principles-wiki.net/principles:model_principle">MP</a>,
                and <a href="http://www.principles-wiki.net/principles:uniformity_principle">UP</a>
            </p>
            <p>
                Rather disregarded principles for these developers are: 
                <a href="http://www.principles-wiki.net/principles:rule_of_explicitness">RoE</a>,
                <a href="http://www.principles-wiki.net/principles:encapsulate_the_concept_that_varies">ECV</a>,
                and <a href="http://www.principles-wiki.net/principles:you_ain_t_gonna_need_it">YAGNI</a>
            </p>
        </div>
        <h2 id="concrete">Concrete</h2>
        <div>
            <p>
                Developers with this attitude directly think in terms of code.
            </p>
            <p>
                Concrete developers directly transfer requirements into code. They are also good at working with and refactoring legacy code that they do not understand completely. They don't have to understand the whole system in all its details and they know that this attitude wouldn't scale either. As soon as a system has a certain level of complexity, one mind cannot understand it fully. Nevertheless a concrete developer can work quite well with such a system. When they refactor they heavyly rely on the boyscout rule. They improve code bottom-up rather than planning it top-down.
            </p>
            <p>
                On the other hand concrete developers may overoptimize unnecessary details and tend to loose sight of the big picture. They may violate achitectural constraints and weaken the overall structure because thinking in terms of packages, layers and dependencies is not in their focus.
            </p>
            <p>
                Concrete developers typically follow the following principles: 
                <a href="http://www.principles-wiki.net/principles:don_t_repeat_yourself">DRY</a>,
                <a href="http://www.principles-wiki.net/principles:high_cohesion">HC</a>,
                <a href="http://www.principles-wiki.net/principles:single_responsibility_principle">SRP</a>,
                <a href="http://www.principles-wiki.net/principles:encapsulate_the_concept_that_varies">ECV</a>,
                and <a href="http://www.principles-wiki.net/principles:open-closed_principle">OCP</a> 
            </p>
            <p>
                Rather disregarded principles for these developers are:
                <a href="http://www.principles-wiki.net/principles:model_principle">MP</a>,
                <a href="http://www.principles-wiki.net/principles:tell_don_t_ask_information_expert">TdA/IE</a>,
                <a href="http://www.principles-wiki.net/principles:principle_of_separate_understandability">PSU</a>,
                and <a href="http://www.principles-wiki.net/principles:liskov_substitution_principle">LSP</a>
            </p>
        </div>
        <h2 id="pragmatic">Pragmatic</h2>
        <div>
            <p>
                Developers with this attitude focus on time to market.
            </p>
            <p>
                The main motivation of such developers is to fulfill the requested requirements as soon as possible. It's the result that counts so tasks are only done if there is a valuable benefit. This approach prevents complexity and overengineering. Furthermore they can use the saved time to implement even more features and deliver benefit to the customer even faster. Followers do not like to reinvent the wheel and use templates, code snippets, etc. to avoid implementing everything by their own. This normally leads to faster solutions and success. Freed from technical or structural sensitivities followers of this dimension adapt very fast to any new environment, rules or specifications for example to a new team. They are also able to bring others down to earth and redirect them to the primary goal.
            </p>
            <p>
                On the other hand pragmatic developers tend to neglect code quality. So while pragamtic developers are really fast at the beginning, they may be slower in the long run as maintainability decreases, bugs show up more often and the code gets less readable.
            </p>
            <p>
                Pragmatic developers typically follow the following principles: 
                <a href="http://www.principles-wiki.net/principles:you_ain_t_gonna_need_it">YAGNI</a>, 
                <a href="http://www.principles-wiki.net/principles:rule_of_explicitness">RoE</a>,
                <a href="http://www.principles-wiki.net/principles:keep_it_simple_stupid">KISS</a>, 
                and <a href="http://www.principles-wiki.net/principles:more_is_more_complex">MIMC</a>
            </p>
            <p>
                Rather disregarded principles for these developers are: 
                <a href="http://www.principles-wiki.net/principles:uniformity_principle">UP</a>, 
                <a href="http://www.principles-wiki.net/principles:generalization_principle">GP</a>,
                <a href="http://www.principles-wiki.net/principles:model_principle">MP</a>, 
                <a href="http://www.principles-wiki.net/principles:liskov_substitution_principle">LSP</a>, 
                <a href="http://www.principles-wiki.net/principles:information_hiding_encapsulation">IH/E</a>, 
                <a href="http://www.principles-wiki.net/principles:dependency_inversion_principle">DIP</a>, 
                <a href="http://www.principles-wiki.net/principles:low_coupling">LC</a>, 
                <a href="http://www.principles-wiki.net/principles:high_cohesion">HC</a>, 
                <a href="http://www.principles-wiki.net/principles:tell_don_t_ask_information_expert">TdA/IE</a>, 
                <a href="http://www.principles-wiki.net/principles:easy_to_use_and_hard_to_misuse">EUHM</a>, 
                and <a href="http://www.principles-wiki.net/principles:invariant_avoidance_principle">IAP</a>
            </p>
        </div>
        <h2 id="idealistic">Idealistic</h2>
        <div>
            <p>
                Developers with this attitude prefer clean solutions.
            </p>
            <p>
                The main motivation of these developers is the observation that while bad quality can be ignored for a short period of time, it is a serious threat in the long run. So idealistic developers like doing things either right or not at all. Idealistic developers care for the software they write and fight for it with all their expertise and professionalism. It is their job to fight this fight against the odds of deadlines, management, and project schedules. It is not enough to finish a project on-time. If the software dies shortly after the "successful" completion of the project, it is still a failure. Idealistic developers know that and will produce high-quality software that works even after the project managers have left for another project.
            </p>
            <p>
                On the other hand idealsitic developers sometimes lose focus on the real requirements and on economical aspects. Software needs to be maintainable but in most cases it doesn't need to be perfect. Idealistic developers sometimes spend too much time on perfection. Furthermore discussions with idealistic developers sometimes can be exhausting and are not always productive. Idealsitic developers work well with others who think similarly but working with other developers who are also idealistic but rather different in in the other dimensions can become quite difficult.
            </p>
            <p>
                A unique property of idealictic developers is that their idealism increases the advantages and disadvantages of the other attributes. So a simple idealistic developer will strive for perfection in simplicity and a powerful idealistic developer will create even more powerful software, etc.
            </p>
            <p>
                Idealistic developers typically follow the following principles: 
                <a href="http://www.principles-wiki.net/principles:uniformity_principle">UP</a>, 
                <a href="http://principles-wiki.net/principles:principle_of_separate_understandability">PSU</a>, 
                <a href="http://www.principles-wiki.net/principles:don_t_repeat_yourself">DRY</a>,
                <a href="http://www.principles-wiki.net/principles:information_hiding_encapsulation">IH/E</a>, 
                furthermore being idealistic adds even more weight on the principles you favor because of the other dimensions 
            </p>
            <p>
                Rather disregarded principles for these developers are: 
                <a href="http://www.principles-wiki.net/principles:you_ain_t_gonna_need_it">YAGNI</a>, 
                and <a href="http://www.principles-wiki.net/principles:rule_of_explicitness">RoE</a>
                although this heavyly depends on the other dimensions
            </p>
        </div>
        <h2 id="technologic">Technologic</h2>
        <div>
            <p>
                Developers with this attitude prefer technically advanced solutions.
            </p>
            <p>
                Technologic developers embrace the fact that lifelong learning is an essential part of their job. Technology evolves faster and faster, new technologies arise, new methodologies become popular, and bad habits slowly die out. New technology can make you more productive and enable you to do things that weren't possible before. They can be your key advantage over your competitor. Techlologic developers are open-minded for technological improvement and new ideas. Likewise they continuously try to improve themselves just like they try to improve their code.
            </p>
            <p>
                On the other hand technologic developers risk riding the wrong horse. Sometimes they experiment too much, invest too much time in learning the wrong technologies and risk the stability and maintainability of their code. Although they are very creative, this ceativity may lead to unnecessarily complex solutions and especially to ones which are hardly understandable by those who don't know all the technologies used. Technologic developers need to play around and feel uncomfortable when they don't get enough freedom. They don't play it safe, they take risks. Sometimes they win and sometimes they lose.
            </p>
            <p>
                Technologic developers typically follow the following principles: 
                <a href="http://www.principles-wiki.net/principles:generalization_principle">GP</a>,
                <a href="http://www.principles-wiki.net/principles:low_coupling">LC</a>,
                <a href="http://principles-wiki.net/principles:murphy_s_law">ML</a>,
                and <a href="http://www.principles-wiki.net/principles:don_t_repeat_yourself">DRY</a>
            </p>
            <p>
                Rather disregarded principles for these developers are: 
                <a href="http://www.principles-wiki.net/principles:rule_of_explicitness">RoE</a>,
                <a href="http://www.principles-wiki.net/principles:uniformity_principle">UP</a>, 
                <a href="http://www.principles-wiki.net/principles:keep_it_simple_stupid">KISS</a>, 
                and <a href="http://www.principles-wiki.net/principles:more_is_more_complex">MIMC</a>, 
            </p>
        </div>
        <h2 id="robust">Robust</h2>
        <div>
            <p>
                Developers with this attitude prefer stabe solutions which stood the test of time.
            </p>
            <p>
                Stability of applications or systems prevents risks and protects from problems. Each kind of change typically contains a risk and limitation of risks also means to limitate changes like new technologies or unnecessary updates. To gain a certain level of homogenous and stable structure instead of heading towards to a chaotic zoo there is a need for standards. These standards lead to better understandable systems. In general only reality proven elements or those that stood a substantiated check will be used in practice. Any kind of magic that mainly increases complexity will be avoided or omitted. Instead of this effort will be invested in protecting oneself from manipulative intrusions. Consequences are that bugs can be investigated more precisely and fixed faster also if source code is unknown. Follower often think beyond the code itself for example about logging, exception handling, security, defensive programming, test strategy, etc.
            </p>
            <p>
                Reaching robustness demands effort and time. In the worst case it means to loose catching up new technologies that would make things easier or faster. In comparison with others that use new technologies it can lead to frustration. Protecting code often also leads to more complex or overweight code that is thus hard to understand. Follower have to take care not being noticed as a guy who slows down everything.
            </p>
            <p>
                Typical applied principles for dimension idealistic are: ML, EUHM, UP, IH/E 
            </p>
            <p>
                Irrelevant principles for this dimension are (maybe also interesting to have an eye on it): KISS
            </p>
        </div>
    </section>
    <section id="comments">
		<div id="comment-template" class="comment">
		    <img src="" alt="" class="avatar">
		    <div>
		        <h5 class="name">Template name</h5><span class="date">Template date</span><br>
		        <p class="text">Template comment</p>
		    </div>
		</div>
		
		<div class="comment-container">
		    <div class="new-button">
		        <span>Write a comment ...</span>
		    </div>
		    <div class="new-form">
		        <input type="text" id="new-comment-name" value="" placeholder="Your name">
		        <input type="text" id="new-comment-email" value="" placeholder="Your e-mail address">
		        <textarea id="new-comment-text"></textarea>
		        <div class="btn btn-primary post-button" disabled="true">Post comment</div>
		        <div class="btn btn-default cancel-button">Cancel</div>
		    </div>
		    <div class="clear"></div>
		</div>  
    </section>
    <footer>
        Please give us <a href="mailto:email@design-types.net">Feedback</a> or discuss with us at <a href="https://www.xing.com/communities/groups/design-principles-patterns-types-08d2-1080100" target="_blank"><img src="./img/xing_logo2.png" alt="XING" height="25" width="25" /></a>
    </footer>
</div>

<script src="bower_components/jquery/dist/jquery.min.js"></script>
<script src="bower_components/jquery-ui/ui/minified/jquery-ui.min.js"></script>
<script src="bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
<script src="dimensions.js"></script>
<script src="comments.js"></script>
</body>
</html>
